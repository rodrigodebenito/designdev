package nyt.io.xml {		import flash.utils.*;		public class XMLParser {				/************************************************************************		*		*************************************************************************/		public static function parseXMLString(str:String):* {						var t:int = getTimer();						var xml:XML = new XML(str);						var nodes:XMLList = xml.elements();			var attrs:XMLList = xml.attributes();						if(nodes.length() == 0 && attrs.length() == 0) {								return getVar(xml.toString())			}						var obj = parseNode(xml,new Object());						trace("XMLParser: Parse took "+(getTimer()-t)+" milliseconds");						return obj;		}				/************************************************************************		*		*************************************************************************/		public static function parseXML(xml:XML):* {						var t:int = getTimer();						var nodes:XMLList = xml.elements();			var attrs:XMLList = xml.attributes();						if(nodes.length() == 0 && attrs.length() == 0) {								return getVar(xml.toString())			}						var obj = parseNode(xml,new Object());						trace("XMLParser: Parse took "+(getTimer()-t)+" milliseconds");						return obj;		}				/************************************************************************		*		*************************************************************************/		protected static function parseNode(xml:XML,pObject:Object):* {						// loops' index			var i:int = 0;						// count of item instances			var nCount:int = 0;						// node and attribute lists			var nodes:XMLList = xml.elements();			var attrs:XMLList = xml.attributes();						// key to hold added node references			var nKey:Object = new Object();															// add atrributes as properties of pObject			for(i=0; i<attrs.length(); i++) {								var aName:String = attrs[i].name().toString();								nCount = nKey[aName];								pObject[aName] = getVar(attrs[i].toString());								if(!nCount) nKey[aName] = 1;				else nKey[aName] = nCount + 1;			}														// add child nodes as properties of pObject			for each(var cn:XML in nodes) {								// repeated vars				var cAttrs:XMLList;				var cObj:Object;				var tmp:*;								// get name of node				var cName:String = cn.localName();								// get count of props with this name				nCount = nKey[cName];								// first element with this name				if(!nCount) {										// update nKey to reflect this as first item with this name					nCount = nKey[cName] = 1;										// add pObject[cName] as object (has children)					if(cn.elements().length() > 0) {												pObject[cName] = parseNode(cn,new Object());					}										// add pObject[cName] as object (has attributes)					else if(cn.attributes().length() > 0) {												cAttrs = cn.attributes();						cObj = new Object();												// add node value as property named "value"						cObj.value = getVar(cn.toString());												// add attributes as properties						for(i=0; i<cAttrs.length(); i++) {										cObj[cAttrs[i].name().toString()] = getVar(cAttrs[i].toString());						}												pObject[cName] = cObj;					}											// add new item to pObject[cName] as primitive (no children or attributes)					else pObject[cName] = getVar(cn.toString());				}								// multiple children with same name, should be put in array				else {										// first repeated item					if(nCount == 1) {												tmp = pObject[cName];												// change pObject[cName] to array and push prev val into it						pObject[cName] = new Array(tmp);					}										// add new item to pObject[cName] array as object (has children)					if(cn.elements().length() > 0) {												var tmpNext = new Object();												pObject[cName].push(parseNode(cn,tmpNext));					}										// add pObject[cName] as object (has attributes)					else if(cn.attributes().length() > 0) {													cAttrs = cn.attributes();						cObj = new Object();												// add node value as property named "value"						cObj.value = getVar(cn.toString());												// add attributes as properties						for(i=0; i<cAttrs.length(); i++) {														cObj[cAttrs[i].name().toString()] = getVar(cAttrs[i].toString());						}												pObject[cName].push(cObj);					}										// add new item to pObject[cName] array as primitive (no children or attributes)					else pObject[cName].push(getVar(cn.toString()));															nKey[cName] = nCount+1;				}			}												// all children and attributes have same name, parent prop should be array			if(nKey[cName] == nodes.length()) {								// set pObject as an array containing pObject[cName]				if(nKey[cName] == 1) {										tmp = pObject[cName];											// change pObject[cName] to array and push prev val into it					pObject = new Array(tmp);				}								// pObject[cName] should already be an array containing the children - set pObject as this array				else pObject = pObject[cName];			}						return pObject;		}				/************************************************************************		*		*************************************************************************/		protected static function getVar(val:String="",dt:String=""):* {						var lVal:String = val.toLowerCase();							if(lVal == "true" || lVal == "false") return (lVal == "true");							else {								var r:RegExp = /[^\d]/g;									if(val == "" || r.test(val)) return new String(val);								return parseFloat(val);			}		}					}}